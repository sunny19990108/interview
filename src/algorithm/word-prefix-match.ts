/**
 * 高效的实现英文单词前缀匹配
 * 有一个单词库，里面几十万甚至百万个单词，输入一个单词的前缀，快速得出单词库里有没有这个单词
 */

// 比如 vscode 插件 codeSpellChecker 当我们输入一个不存在的单词会给出提示
const haabc = 1;

// 主要考虑单词库用什么数据结构来实现

// 数组： 也就是一个长度为几十万的数组，查询一个单词前缀是否存在时，需要遍历数组，然后没一项使用String.indexOf() 看是否匹配
// const arr = ['bst','boss','boot','about','out','in','happy','you', ...];
// 时间复杂度 > O(n)
// 如果是一个简单数组还可，但这里是一个巨大的数组，所以时间复杂度还是过高了

// Hash Table (哈希表)
// 有明确范围的数据（比如：26 个英文字母）考虑用哈希表实现
// 把数组拆成一个以 26 个英文字母为 key 的对象，value 里面可以继续按照 26 个英文字母拆分，就这样一直拆分下去
// const obj = {
//     'a': {
//         'b': {
//             o: {...}
//         }
//     },
//     'b': {
//         's': {
//             't': {...}
//         }
//         'o': {
//             's': {
//                 's': {...},
//             },
//             'o': {
//                 't': {...},
//             }
//         }
//     },
//     'c': {...},
//     'o': {
//         'u': {
//             't': {...},
//         }
//     },
//     'y': {
//         'o': {
//             'u': {...},
//         }
//     }

// }
// 查询 boss  obj.b.o.s.s 时间复杂度 O(4) 
// 数组实现 换成 哈希表实现 以空间换时间，时间复杂度由 O(n) 降为 O(m)


// Hash Table 逻辑结构

// 可以用以下物理结构实现
// js Object 
// js Map
// C 结构体
// java HashMap
